<?php

namespace Modules\Tenant\Tests\Unit\Pipes;

use Illuminate\Container\Container;
use Illuminate\Contracts\Config\Repository as ConfigRepository;
use Illuminate\Contracts\Redis\Factory as RedisFactory;
use Illuminate\Foundation\Application;
use Illuminate\Log\LogManager;
use Illuminate\Redis\RedisManager;
use Illuminate\Support\Facades\Redis;
use Modules\Tenant\Models\Tenant;
use Modules\Tenant\Pipes\RedisConfigPipe;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\Attributes\DataProvider;
use PHPUnit\Framework\Attributes\Group;
use PHPUnit\Framework\MockObject\MockObject;
use PHPUnit\Framework\TestCase;

/**
 * Unit tests for the RedisConfigPipe class.
 */
#[CoversClass(RedisConfigPipe::class)]
#[Group('tenant-module')]
#[Group('tenant-pipes')]
class RedisConfigPipeTest extends TestCase
{
    private RedisConfigPipe $pipe;
    private ConfigRepository|MockObject $config;
    private Application|MockObject $app;
    private ?Container $originalContainer = null;

    protected function setUp(): void
    {
        parent::setUp();
        
        $this->originalContainer = Container::getInstance();
        
        $this->app = $this->createPartialMock(Application::class, [
            'make', 'bound', 'environment', 'extend', 'forgetInstance'
        ]);
        $this->config = $this->createMock(ConfigRepository::class);
        
        Container::setInstance($this->app);
        
        $logger = $this->createMock(LogManager::class);
        $logger->expects($this->any())->method('debug');
        $logger->expects($this->any())->method('error');
            
        $this->app->method('make')
            ->willReturnMap([
                ['config', [], $this->config],
                ['log', [], $logger]
            ]);
            
        $this->app->method('environment')
            ->willReturn(true);
            
        $this->pipe = new RedisConfigPipe();
    }

    public function testHandleSkipsWhenRedisNotAvailable(): void
    {
        $tenant = $this->createMock(Tenant::class);
        $tenant->id = '123';
        $tenantConfig = ['redis_host' => 'redis.example.com'];
        
        $this->app->expects($this->once())
            ->method('bound')
            ->with(RedisFactory::class)
            ->willReturn(false);
        
        $this->config->expects($this->never())->method('set');
        
        $result = $this->pipe->handle($tenant, $this->config, $tenantConfig, function ($data) {
            return $data;
        });
        
        $this->assertSame($tenant, $result['tenant']);
        $this->assertSame($this->config, $result['config']);
        $this->assertSame($tenantConfig, $result['tenantConfig']);
    }

    public function testHandleAppliesAllRedisConfig(): void
    {
        $tenant = $this->createMock(Tenant::class);
        $tenant->id = '123';
        $tenantConfig = [
            'redis_client' => 'predis',
            'redis_host' => 'redis.tenant.com',
            'redis_password' => 'secret',
            'redis_port' => 6380,
            'redis_prefix' => 'custom_tenant_',
        ];
        
        $this->app->expects($this->any())
            ->method('bound')
            ->with(RedisFactory::class)
            ->willReturn(true);
        
        $expectedSets = [
            ['database.redis.client', 'predis'],
            ['database.redis.default.host', 'redis.tenant.com'],
            ['database.redis.default.password', 'secret'],
            ['database.redis.default.port', 6380],
            ['database.redis.default.prefix', 'custom_tenant_'],
            ['database.redis.cache.prefix', 'custom_tenant_'],
        ];
        
        $this->config->expects($this->exactly(count($expectedSets)))
            ->method('set')
            ->willReturnCallback(function ($key, $value) use (&$expectedSets) {
                $expected = array_shift($expectedSets);
                $this->assertEquals($expected[0], $key);
                $this->assertEquals($expected[1], $value);
                return null;
            });
        
        $this->app->expects($this->once())->method('extend');
        $this->app->expects($this->exactly(2))->method('forgetInstance');
        
        $result = $this->pipe->handle($tenant, $this->config, $tenantConfig, function ($data) {
            return $data;
        });
        
        $this->assertSame($tenant, $result['tenant']);
    }

    public function testHandleSetsDefaultPrefixWhenNotProvided(): void
    {
        $tenant = $this->createMock(Tenant::class);
        $tenant->id = '456';
        $tenantConfig = ['redis_host' => 'redis.example.com'];
        
        $this->app->expects($this->any())
            ->method('bound')
            ->with(RedisFactory::class)
            ->willReturn(true);
        
        $callIndex = 0;
        $this->config->expects($this->exactly(3))
            ->method('set')
            ->willReturnCallback(function ($key, $value) use (&$callIndex) {
                $expected = [
                    ['database.redis.default.host', 'redis.example.com'],
                    ['database.redis.default.prefix', 'tenant_456:'],
                    ['database.redis.cache.prefix', 'tenant_456:']
                ];
                $this->assertEquals($expected[$callIndex][0], $key);
                $this->assertEquals($expected[$callIndex][1], $value);
                $callIndex++;
                return null;
            });
        
        $this->app->expects($this->once())->method('extend');
        $this->app->expects($this->exactly(2))->method('forgetInstance');
        
        $result = $this->pipe->handle($tenant, $this->config, $tenantConfig, function ($data) {
            return $data;
        });
        
        $this->assertSame($tenant, $result['tenant']);
    }

    #[DataProvider('partialConfigProvider')]
    public function testHandleWithPartialConfig(array $tenantConfig, int $expectedSetCalls): void
    {
        $tenant = $this->createMock(Tenant::class);
        $tenant->id = '123';
        
        $this->app->expects($this->any())
            ->method('bound')
            ->with(RedisFactory::class)
            ->willReturn(true);
        
        $this->config->expects($this->exactly($expectedSetCalls))
            ->method('set');
        
        if ($expectedSetCalls > 0) {
            $this->app->expects($this->once())->method('extend');
            $this->app->expects($this->exactly(2))->method('forgetInstance');
        }
        
        $result = $this->pipe->handle($tenant, $this->config, $tenantConfig, function ($data) {
            return $data;
        });
        
        $this->assertSame($tenant, $result['tenant']);
    }

    public static function partialConfigProvider(): array
    {
        return [
            'only client' => [
                ['redis_client' => 'phpredis'],
                3, // client + default prefixes
            ],
            'only host' => [
                ['redis_host' => 'localhost'],
                3, // host + default prefixes
            ],
            'only password' => [
                ['redis_password' => 'secret'],
                3, // password + default prefixes
            ],
            'empty config still sets default prefix' => [
                [],
                2, // default prefixes
            ],
        ];
    }

    public function testRefreshRedisConnectionsHandlesException(): void
    {
        $tenant = $this->createMock(Tenant::class);
        $tenant->id = '123';
        $tenantConfig = ['redis_host' => 'redis.example.com'];
        
        $this->app->expects($this->any())
            ->method('bound')
            ->with(RedisFactory::class)
            ->willReturn(true);
        
        $this->config->expects($this->any())->method('set');
        
        $this->app->expects($this->once())
            ->method('extend')
            ->willThrowException(new \Exception('Extend failed'));
        
        // Should not throw exception, but handle it gracefully
        $result = $this->pipe->handle($tenant, $this->config, $tenantConfig, function ($data) {
            return $data;
        });
        
        $this->assertSame($tenant, $result['tenant']);
    }

    public function testResetResourcesRefreshesRedisConnections(): void
    {
        Container::setInstance(null);
        $mockApp = $this->createPartialMock(Application::class, [
            'bound', 'make', 'extend', 'forgetInstance', 'environment'
        ]);
        Container::setInstance($mockApp);
        
        $mockLogger = $this->createMock(LogManager::class);
        $mockConfig = $this->createMock(ConfigRepository::class);
        
        $mockApp->expects($this->once())
            ->method('bound')
            ->with(RedisFactory::class)
            ->willReturn(true);
            
        $mockApp->method('make')
            ->willReturnMap([
                ['log', [], $mockLogger],
                ['config', [], $mockConfig]
            ]);
            
        $mockApp->method('environment')->willReturn(true);
        
        $mockConfig->method('get')
            ->willReturnMap([
                ['database.redis.client', null, 'phpredis'],
                ['database.redis', null, []]
            ]);
        
        $mockApp->expects($this->once())
            ->method('extend')
            ->with(RedisFactory::class);
            
        $callIndex = 0;
        $mockApp->expects($this->exactly(2))
            ->method('forgetInstance')
            ->willReturnCallback(function ($arg) use (&$callIndex) {
                $expected = [RedisFactory::class, 'redis'];
                $this->assertEquals($expected[$callIndex], $arg);
                $callIndex++;
                return null;
            });
        
        $mockLogger->expects($this->once())->method('debug');
        
        RedisConfigPipe::resetResources();
    }

    public function testResetResourcesHandlesException(): void
    {
        Container::setInstance(null);
        $mockApp = $this->createPartialMock(Application::class, [
            'bound', 'make', 'extend'
        ]);
        Container::setInstance($mockApp);
        
        $mockLogger = $this->createMock(LogManager::class);
        
        $mockApp->expects($this->once())
            ->method('bound')
            ->with(RedisFactory::class)
            ->willReturn(true);
            
        $mockApp->method('make')
            ->willReturnMap([
                ['log', [], $mockLogger]
            ]);
            
        $mockApp->expects($this->once())
            ->method('extend')
            ->willThrowException(new \Exception('Test exception'));
        
        $mockLogger->expects($this->once())
            ->method('error')
            ->with($this->stringContains('Failed to reset Redis connections'));
        
        RedisConfigPipe::resetResources();
    }

    public function testResetResourcesSkipsWhenRedisNotAvailable(): void
    {
        Container::setInstance(null);
        $mockApp = $this->createPartialMock(Application::class, ['bound']);
        Container::setInstance($mockApp);
        
        $mockApp->expects($this->once())
            ->method('bound')
            ->with(RedisFactory::class)
            ->willReturn(false);
        
        RedisConfigPipe::resetResources();
    }

    public function testHandlesReturnsCorrectKeys(): void
    {
        $handles = $this->pipe->handles();
        
        $expectedKeys = [
            'redis_client',
            'redis_host',
            'redis_password',
            'redis_port',
            'redis_prefix',
        ];
        
        foreach ($expectedKeys as $key) {
            $this->assertContains($key, $handles);
        }
        $this->assertCount(count($expectedKeys), $handles);
    }

    public function testPriorityReturnsCorrectValue(): void
    {
        $priority = $this->pipe->priority();
        
        $this->assertEquals(84, $priority);
    }

    public function testIsRedisAvailableReturnsFalseWhenRedisExtensionMissing(): void
    {
        $this->app->expects($this->once())
            ->method('bound')
            ->with(RedisFactory::class)
            ->willReturn(true);
        
        // We can't easily mock extension_loaded, but we can test the logic
        // by creating a test double that overrides isRedisAvailable
        $pipe = new class extends RedisConfigPipe {
            protected function isRedisAvailable(): bool
            {
                return false;
            }
        };
        
        $tenant = $this->createMock(Tenant::class);
        $tenantConfig = ['redis_host' => 'redis.example.com'];
        
        $this->config->expects($this->never())->method('set');
        
        $result = $pipe->handle($tenant, $this->config, $tenantConfig, function ($data) {
            return $data;
        });
        
        $this->assertSame($tenant, $result['tenant']);
    }

    protected function tearDown(): void
    {
        if ($this->originalContainer) {
            Container::setInstance($this->originalContainer);
        }
        
        parent::tearDown();
    }
}